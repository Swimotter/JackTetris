// MemoryTracker.jack - Display aggregator with preallocated strings
class MemoryTracker {
    /**
     * Aggregates and displays memory statistics from all tracked classes
     * Each class maintains its own allocation counter
     * Uses preallocated strings to prevent memory leaks
     **/

    // Static preallocated strings (shared across all uses)
    static String titleLabel;
    static String blocksLabel;
    static String bigintLabel;
    static String bagsLabel;
    static String gridsLabel;
    static String holdsLabel;
    static String scoresLabel;
    static String intBuffer;
    static boolean initialized;

    /** Initialize static string pool - call once at app start */
    function void init() {
        if (initialized) {
            return;  //already initialized
        }
        
        //allocate strings with exact sizes needed
        let titleLabel = String.new(13);
        let blocksLabel = String.new(8);
        let bigintLabel = String.new(8);
        let bagsLabel = String.new(8);
        let gridsLabel = String.new(8);
        let holdsLabel = String.new(8);
        let scoresLabel = String.new(8);
        let intBuffer = String.new(12);  // Max int is -32768
        
        //build the labels once - these never change
        do MemoryTracker.buildString(titleLabel, "MEMORY DEBUG:");
        do MemoryTracker.buildString(blocksLabel, "Blocks: ");
        do MemoryTracker.buildString(bigintLabel, "BigInt: ");
        do MemoryTracker.buildString(bagsLabel, "Bags:   ");
        do MemoryTracker.buildString(gridsLabel, "Grids:  ");
        do MemoryTracker.buildString(holdsLabel, "Holds:  ");
        do MemoryTracker.buildString(scoresLabel, "Scores: ");
        
        let initialized = true;
        return;
    }
    
    /** 
     * Helper: Build a string from a literal (copies characters) 
     * WARNING: This creates a temporary string that leaks!
     * Only call this during initialization, not in hot loops
     */
    function void buildString(String dest, String source) {
        var int i, len;
        var char c;
        
        let len = source.length();
        let i = 0;
        
        while (i < len) {
            let c = source.charAt(i);
            do dest.appendChar(c);
            let i = i + 1;
        }
        
        return;
    }
    
    /** 
     * Convert integer to string using reusable buffer (no memory leak)
     * Returns the string representation in intBuffer
     */
    function String intToString(int value) {
        var int divisor, digit, temp;
        var boolean started;
        
        //clear buffer by using eraseLastChar until empty
        while (intBuffer.length() > 0) {
            do intBuffer.eraseLastChar();
        }
        
        //handle negative
        if (value < 0) {
            do intBuffer.appendChar(45);  // '-'
            let value = -value;
        }
        
        //handle zero
        if (value = 0) {
            do intBuffer.appendChar(48);  // '0'
            return intBuffer;
        }
        
        //build digits (max value is 32767, so 10000 is enough)
        let divisor = 10000;
        let started = false;
        
        while (divisor > 0) {
            let digit = value / divisor;
            
            if ((digit > 0) | started) {
                do intBuffer.appendChar(48 + digit);  // '0' + digit
                let started = true;
            }
            
            let temp = digit * divisor;
            let value = value - temp;
            let divisor = divisor / 10;
        }
        
        return intBuffer;
    }
    
    /** Display memory stats by querying each class - NO NEW ALLOCATIONS */
    function void displayStats() {
        var String countStr;
        
        //display title
        do Output.moveCursor(14, 1);
        do Output.printString(titleLabel);
        
        //display Blocks count
        do Output.moveCursor(15, 1);
        do Output.printString(blocksLabel);
        let countStr = MemoryTracker.intToString(Blocks.getAllocCount());
        do Output.printString(countStr);
        
        //display BigInt count
        do Output.moveCursor(16, 1);
        do Output.printString(bigintLabel);
        let countStr = MemoryTracker.intToString(BigInt.getAllocCount());
        do Output.printString(countStr);
        
        //display Bags count
        do Output.moveCursor(17, 1);
        do Output.printString(bagsLabel);
        let countStr = MemoryTracker.intToString(Bag.getAllocCount());
        do Output.printString(countStr);
        
        //display Grids count
        do Output.moveCursor(18, 1);
        do Output.printString(gridsLabel);
        let countStr = MemoryTracker.intToString(Grid.getAllocCount());
        do Output.printString(countStr);
        
        //display Holds count
        do Output.moveCursor(19, 1);
        do Output.printString(holdsLabel);
        let countStr = MemoryTracker.intToString(Hold.getAllocCount());
        do Output.printString(countStr);
        
        //display Scores count
        do Output.moveCursor(20, 1);
        do Output.printString(scoresLabel);
        let countStr = MemoryTracker.intToString(Score.getAllocCount());
        do Output.printString(countStr);
        
        return;
    }
    
    /** Dispose all preallocated strings - call on app exit */
    function void dispose() {
        if (~initialized) {
            return;  //nothing to dispose
        }
        
        do titleLabel.dispose();
        do blocksLabel.dispose();
        do bigintLabel.dispose();
        do bagsLabel.dispose();
        do gridsLabel.dispose();
        do holdsLabel.dispose();
        do scoresLabel.dispose();
        do intBuffer.dispose();
        
        let initialized = false;
        return;
    }
}