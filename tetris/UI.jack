class UI {
	/**
	* Tetris UI Drawing System
	*
	* Handles all UI elements outside of the main grid:
	* - Hold piece box
	* - Next piece preview box
	*
	* Layout uses the LEFT and RIGHT spaces (196px each)
	* defined in Grid
	*
	* Uses preallocated strings to prevent memory leaks
	**/

	static int holdBoxX, holdBoxY, holdBoxSize;
	static int nextBoxX, nextBoxY, nextBoxSize;
	
	// Preallocated strings
	static String scoreLabel;
	static String levelLabel;
	static String comboLabel;
	static String holdLabel;
	static String nextLabel;
	static String comboSuffix;
	static String dashLabel;
	static String spacesLabel;
	static boolean initialized;

	function void init() {
		if (initialized) {
			return;  // Already initialized
		}
		
		//box positions
		let holdBoxX = 15;
		let holdBoxY = 120;
		let holdBoxSize = 60;

		let nextBoxX = 360;
		let nextBoxY = 30;
		let nextBoxSize = 80;
		
		//allocate strings once
		let scoreLabel = String.new(7);
		let levelLabel = String.new(7);
		let comboLabel = String.new(7);
		let holdLabel = String.new(4);
		let nextLabel = String.new(4);
		let comboSuffix = String.new(1);
		let dashLabel = String.new(1);
		let spacesLabel = String.new(2);
		
		//build labels
		do UI.buildString(scoreLabel, "SCORE: ");
		do UI.buildString(levelLabel, "LEVEL: ");
		do UI.buildString(comboLabel, "COMBO: ");
		do UI.buildString(holdLabel, "HOLD");
		do UI.buildString(nextLabel, "NEXT");
		do UI.buildString(comboSuffix, "x");
		do UI.buildString(dashLabel, "-");
		do UI.buildString(spacesLabel, "  ");
		
		let initialized = true;
		return;
	}
	
	/** Helper: Build a string from a literal */
	function void buildString(String dest, String source) {
		var int i, len;
		var char c;
		
		let len = source.length();
		let i = 0;
		
		while (i < len) {
			let c = source.charAt(i);
			do dest.appendChar(c);
			let i = i + 1;
		}
		
		return;
	}

	function void drawScoreText() {
		do Output.moveCursor(4, 1);
		do Output.printString(scoreLabel);
		return;
	}

	function void drawLevelText() {
		do Output.moveCursor(6, 1);
		do Output.printString(levelLabel);
		return;
	}

	function void drawComboText() {
		do Output.moveCursor(8, 1);
		do Output.printString(comboLabel);
		return;
	}

	//draw hold box with piece preview
	function void drawHoldBox() {
		//draw hold box border
		do Screen.setColor(true);
		do Screen.drawRectangle(holdBoxX, holdBoxY, holdBoxX + holdBoxSize, holdBoxY + holdBoxSize);
		do Screen.setColor(false);
		do Screen.drawRectangle(holdBoxX + 2, holdBoxY + 2, holdBoxX + holdBoxSize - 2, holdBoxY + holdBoxSize - 2);

		//draw label
		do Output.moveCursor(10, 1);
		do Output.printString(holdLabel);
		return;
	}

	//draw next piece preview box
	function void drawNextBox() {
		//draw next box border
		do Screen.setColor(true);
		do Screen.drawRectangle(nextBoxX, nextBoxY, nextBoxX + nextBoxSize, nextBoxY + nextBoxSize);
		do Screen.setColor(false);
		do Screen.drawRectangle(nextBoxX + 2, nextBoxY + 2, nextBoxX + nextBoxSize - 2, nextBoxY + nextBoxSize - 2);

		//draw label
		do Output.moveCursor(2, 46);
		do Output.printString(nextLabel);
		return;
	}

	function void drawHoldPiece(Blocks heldBlock) {
		//clear hold area
		do Screen.setColor(false);
		do Screen.drawRectangle(holdBoxX + 2, holdBoxY + 2, holdBoxX + holdBoxSize - 2, holdBoxY + holdBoxSize - 2);

		//only draw if there is a held piece
		if (~(heldBlock = null)) {
			do UI.drawPreviewPiece(heldBlock, holdBoxX + 10, holdBoxY + 20, 8);
		}
		return;
	}

	function void drawNextPiece(Blocks nextBlock) {
		//clear next piece area
		do Screen.setColor(false);
		do Screen.drawRectangle(nextBoxX + 2, nextBoxY + 2, nextBoxX + nextBoxSize - 2, nextBoxY + nextBoxSize - 2);

		//only draw if there is a next piece
		if (~(nextBlock = null)) {
			do UI.drawPreviewPiece(nextBlock, nextBoxX + 10, nextBoxY + 20, 8);
		}
		return;
	}

	//draw a preview of a piece (smaller, centered in box)
	function void drawPreviewPiece(Blocks block, int offsetX, int offsetY, int cellSize) {
		var Array shape;
		var int i, cellX, cellY;
		var int x1, y1, x2, y2;

		let shape = block.getShape();

		do Screen.setColor(true);
		let i = 0;

		while (i < 8) {
			let cellX = shape[i];
			let cellY = shape[i + 1];

			let x1 = offsetX + (cellX * cellSize);
			let y1 = offsetY + (cellY * cellSize);
			let x2 = x1 + cellSize - 1;
			let y2 = y1 + cellSize - 1;

			do Screen.drawRectangle(x1, y1, x2, y2);
			let i = i + 2;
		}

		return;
	}

	function void drawScore(BigInt score) {
		//clear score area
		do Screen.setColor(false);
		do Screen.drawRectangle(42,24,180,32);

		do Output.moveCursor(4, 7);
		do score.print();
		return;
	}

	function void drawLevel(int level) {
		//clear level area
		do Screen.setColor(false);
		do Screen.drawRectangle(42, 40, 180, 48);

		do Output.moveCursor(6, 7);
		do Output.printInt(level);
		return;
	}

	function void drawCombo(int combo) {
		//clear combo area
		do Screen.setColor(false);
		do Screen.drawRectangle(42, 56, 180, 64);

		do Output.moveCursor(8, 7);
		if (combo > 0) {
			do Output.printInt(combo);
			do Output.printString(comboSuffix);
		} else {
			do Output.printString(spacesLabel);
			do Output.moveCursor(8, 7);
			do Output.printString(dashLabel);
		}
		return;
	}

	//clear ui regions
	function void clearHoldArea() {
		do Screen.setColor(false);
		do Screen.drawRectangle(10, 115, 90, 195);
		return;
	}

	function void clearNextArea() {
		do Screen.setColor(false);
		do Screen.drawRectangle(350, 25, 480, 125);
		return;
	}

	//draw all static ui elements
	function void drawAll() {
		var BigInt zeroScore;

		do UI.drawHoldBox();
		do UI.drawNextBox();
		do UI.drawScoreText();
		do UI.drawLevelText();
		do UI.drawComboText();

		//create temp BigInt with value 0 and dispose after use
		let zeroScore = BigInt.new();
		do UI.drawScore(zeroScore);
		do zeroScore.dispose();
		return;
	}
	
	/** Dispose all preallocated strings - call on app exit */
	function void dispose() {
		if (~initialized) {
			return;
		}
		
		do scoreLabel.dispose();
		do levelLabel.dispose();
		do comboLabel.dispose();
		do holdLabel.dispose();
		do nextLabel.dispose();
		do comboSuffix.dispose();
		do dashLabel.dispose();
		do spacesLabel.dispose();
		
		let initialized = false;
		return;
	}
}