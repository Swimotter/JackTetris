class Grid {
	/**
	 0                196px              316px            512px
	 ├──────────────────┼──────────────────┼──────────────┤
   0 ┤                  │                  │              │
	 │                  │                  │              │
   8 ┤                  ┌──────────────────┐              │
	 │                  │                  │              │
	 │     LEFT         │   TETRIS BOARD   │    RIGHT     │
	 │    SPACE         │   (120×240 px)   │    SPACE     │
	 │   (196 px)       │                  │   (196 px)   │
	 │                  │                  │              │
 248 ┤                  └──────────────────┘              │
	 │                  │                  │              │
 256 ┴──────────────────┴──────────────────┴──────────────┘
	 0                196px              316px            512px

	Cell size = 12x12 pixels
	Grid size = 10x20 cells
	**/

	static int cellSize;
	static int offsetX, offsetY;

	//2D array representing grid
	field Array board;
	field int width, height;

	//SRS kick table
	static Array kickTableJLSTZ;
	static Array kickTableI;

	function void init() {
		let  cellSize = 12;
		let  offsetX = 195; // (512 - (10*12)) / 2 = 196
		let  offsetY = 7; // (256 - (20*12)) / 2 = 8

		do Grid.initKickTables();
		return;
	}

	constructor Grid new(int w, int h) {
		let width = w;
		let height = h;
		let board = Array.new(width * height);

		do clear();
		return this;
	}

	//convert 2D coords to 1D index
	method int getIndex(int x, int y) {
		return (y * width) + x;
	}

	//bounds check
	method boolean inBounds(int x, int y) {
		return (~((x < 0) | (x > (width - 1)) | (y < 0) | (y > (height - 1)))); //all parenthesis necessary
	}

	//occupancy check
	method boolean isEmpty(int x, int y) {
		var int index;
		if (~inBounds(x, y)) {
			return false;
		}
		let index = getIndex(x, y);
		return board[index] = 0;
	}

	//valid position check for block
	method boolean isValidCell(int x, int y) {
		if (~inBounds(x, y)) {
			return false;
		}
		return isEmpty(x, y);
	}

	method boolean canMoveTo(Blocks block, int newX, int newY) {
		var Array shape;
		var int i, cellX, cellY;
		let shape = block.getShape();
		let i = 0;
		while (i < 8) { //4 pairs of (dx, dy)
			let cellX = newX + shape[i];
			let cellY = newY + shape[i + 1];

			//Check bounds and occupancy
			if (~isValidCell(cellX, cellY)) {
				return false;
			}

			let i = i + 2;
		}
		return true;
	}

	//check if block can be placed at its current position
	method boolean canPlaceBlock(Blocks block) {
		var Array shape;
		var int i, cellX, cellY;

		let shape = block.getShape();
		let i = 0;

		while (i < 8) {
			let cellX = block.getX() + shape[i];
			let cellY = block.getY() + shape[i + 1];
			if (~isValidCell(cellX, cellY)) {
				return false;
			}
			let i = i + 2;
		}
		return true;
	}

	method boolean canPlaceBlockAt(Blocks block, int testX, int testY, int testRotation) { //test position
		var Array shape;
		var int i, cellX, cellY;
		var int oldX, oldY, oldRotation;
		var boolean result;

		//save current state
		let oldX = block.getX();
		let oldY = block.getY();
		let oldRotation = block.getRotation();

		//temp set test state
		do block.setPosition(testX, testY);
		do block.setRotation(testRotation);

		//test if valid
		let result = canPlaceBlock(block);

		//restore
		do block.setPosition(oldX, oldY);
		do block.setRotation(oldRotation);

		return result;
	}

	//try to rotate block clockwise with SRS wall kicks
	method boolean tryRotateBlockCW(Blocks block) {
		var int blockType, oldRotation, newRotation, kickTableIndex;
		var Array kickOffsets;
		var int i, offsetX, offsetY;
		var int testX, testY;

		let blockType = block.getType();

		//O doesnt rotate
		if (blockType = 3) {
			return false;
		}

		let oldRotation = block.getRotation();
		let newRotation = oldRotation + 1;
		if (newRotation > 3) {
			let newRotation = 0;
		}

		//get the appropriate kick table index
		let kickTableIndex = oldRotation * 2;

		//get kick offsets array
		if (blockType = 0) {
			let kickOffsets = kickTableI[kickTableIndex];
		} else {
			let kickOffsets = kickTableJLSTZ[kickTableIndex];
		}

		//try each offset
		let i = 0;
		while (i < 10) {
			let offsetX = kickOffsets[i];
			let offsetY = kickOffsets[i + 1];

			let testX = block.getX() + offsetX;
			let testY = block.getY() + offsetY;

			//check if valid
			if (canPlaceBlockAt(block, testX, testY, newRotation)) {
				//success, apply
				do block.setPosition(testX, testY);
				do block.setRotation(newRotation);
				return true;
			}

			let i = i + 2;
		}
		return false;
	}

	//try to rotate block counter-clockwise with SRS wall kicks
	method boolean tryRotateBlockCCW(Blocks block) {
		var int blockType, oldRotation, newRotation, kickTableIndex;
		var Array kickOffsets;
		var int i, offsetX, offsetY;
		var int testX, testY;

		let blockType = block.getType();

		//O doesnt rotate
		if (blockType = 3) {
			return false;
		}

		let oldRotation = block.getRotation();
		let newRotation = oldRotation - 1;
		if (newRotation < 0) {
			let newRotation = 3;
		}

		//get appropration kick table index
		if (oldRotation = 0) {
			let kickTableIndex = 7;
		}
		if (oldRotation = 1) {
			let kickTableIndex = 1;
		}
		if (oldRotation = 2) {
			let kickTableIndex = 3;
		}
		if (oldRotation = 3) {
			let kickTableIndex = 5;
		}

		//get kick offsets array
		if (blockType = 0) {
			let kickOffsets = kickTableI[kickTableIndex];
		} else {
			let kickOffsets = kickTableJLSTZ[kickTableIndex];
		}

		//try each offset
		let i = 0;
		while (i < 10) {
			let offsetX = kickOffsets[i];
			let offsetY = kickOffsets[i + 1];

			let testX = block.getX() + offsetX;
			let testY = block.getY() + offsetY;

			//check if valid
			if (canPlaceBlockAt(block, testX, testY, newRotation)) {
				//success, apply
				do block.setPosition(testX, testY);
				do block.setRotation(newRotation);
				return true;
			}

			let i = i + 2;
		}
		return false;
	}

	//place block on grid (mark cells occupied)
	method void placeBlock(Blocks block) {
		var Array shape;
		var int i, cellX, cellY, index;
		var int blockType;

		let shape = block.getShape();
		let blockType = block.getType() + 1; //store as 1-7 to differentiate from empty(0)
		let i = 0;

		while (i < 8) {
			let cellX = block.getX() + shape[i];
			let cellY = block.getY() + shape[i + 1];

			if (inBounds(cellX, cellY)) {
				let index = getIndex(cellX, cellY);
				let board[index] = blockType;
			}
			let i = i + 2; //next pair
		}
		return;
	}

	method boolean isLineFull(int row) {
		var int col;
		let col = 0;

		while (col < width) {
			if (isEmpty(col, row)) {
				return false;
			}
			let col = col + 1;
		}
		return true;
	}

	method void clearLine(int row) {
		var int currentRow, col, index, aboveIndex;

		if (~inBounds(0, row)) {
			return;
		}

		//start from cleared row and move up
		let currentRow = row;
		while (currentRow > 0) {
			let col = 0;
			while (col < width) {
				let index = getIndex(col, currentRow);
				let aboveIndex = getIndex(col, currentRow - 1);
				let board[index] = board[aboveIndex];
				let col = col + 1;
			}
			let currentRow = currentRow - 1;
		}
		//Clear top row
		let col = 0;
		while (col < width) {
			let index = getIndex(col, 0);
			let board[index] = 0;
			let col = col + 1;
		}
		return;
	}

	method int clearLines() {
		var int row, linesCleared, topAffectedRow;
		let row = height - 1;
		let linesCleared = 0;
		let topAffectedRow = height;

		while (row > -1) {
			if (isLineFull(row)) {
				do clearLine(row);
				let linesCleared = linesCleared + 1;
				let topAffectedRow = row;
			}
			else {
				let row = row - 1;
			}
		}
		return linesCleared;
	}

	method int getCell(int x, int y) {
		var int index;
		if (~inBounds(x, y)) {
			return -1;
		}
		let index = getIndex(x, y);
		return board[index];
	}

	method void clear() {
		var int i;
		let i = 0;

		while (i < (width * height)) {
			let board[i] = 0;
			let i = i + 1;
		}
		return;
	}

	//getters
	method int getWidth() {
		return width;
	}

	method int getHeight() {
		return height;
	}

	function int getCellSize() {
		return cellSize;
	}

	function int getOffsetX() {
		return offsetX;
	}

	function int getOffsetY() {
		return offsetY;
	}

	method void dispose() {
		do board.dispose();
		do Memory.deAlloc(this);
		return;
	}

	function void initKickTables() {
		// Separate variables for JLSTZ kick table (8 rotations)
		var Array jlstz_0to1, jlstz_1to0, jlstz_1to2, jlstz_2to1;
		var Array jlstz_2to3, jlstz_3to2, jlstz_3to0, jlstz_0to3;
		
		// Separate variables for I kick table (8 rotations)
		var Array i_0to1, i_1to0, i_1to2, i_2to1;
		var Array i_2to3, i_3to2, i_3to0, i_0to3;

		//init JLSTZ kick table (4 rotations * 2 directions = 8 arrays)
		//each array contains 5 kick attempts (x,y pairs = 10 ints)
		let kickTableJLSTZ = Array.new(8);

		//0->R (0->1): Test offsets
		let jlstz_0to1 = Array.new(10);
		let jlstz_0to1[0] = 0; let jlstz_0to1[1] = 0;
		let jlstz_0to1[2] = -1; let jlstz_0to1[3] = 0;
		let jlstz_0to1[4] = -1; let jlstz_0to1[5] = 1;
		let jlstz_0to1[6] = 0; let jlstz_0to1[7] = -2;
		let jlstz_0to1[8] = -1; let jlstz_0to1[9] = -2;
		let kickTableJLSTZ[0] = jlstz_0to1;

		//R->0 (1->0): Reverse 0->1
		let jlstz_1to0 = Array.new(10);
		let jlstz_1to0[0] = 0; let jlstz_1to0[1] = 0;
		let jlstz_1to0[2] = 1; let jlstz_1to0[3] = 0;
		let jlstz_1to0[4] = 1; let jlstz_1to0[5] = -1;
		let jlstz_1to0[6] = 0; let jlstz_1to0[7] = 2;
		let jlstz_1to0[8] = 1; let jlstz_1to0[9] = 2;
		let kickTableJLSTZ[1] = jlstz_1to0;

		//R->2 (1->2): Test offsets
		let jlstz_1to2 = Array.new(10);
		let jlstz_1to2[0] = 0; let jlstz_1to2[1] = 0;
		let jlstz_1to2[2] = 1; let jlstz_1to2[3] = 0;
		let jlstz_1to2[4] = 1; let jlstz_1to2[5] = -1;
		let jlstz_1to2[6] = 0; let jlstz_1to2[7] = 2;
		let jlstz_1to2[8] = 1; let jlstz_1to2[9] = 2;
		let kickTableJLSTZ[2] = jlstz_1to2;

		//2->R (2->1): Reverse of 1->2
		let jlstz_2to1 = Array.new(10);
		let jlstz_2to1[0] = 0; let jlstz_2to1[1] = 0;
		let jlstz_2to1[2] = -1; let jlstz_2to1[3] = 0;
		let jlstz_2to1[4] = -1; let jlstz_2to1[5] = 1;
		let jlstz_2to1[6] = 0; let jlstz_2to1[7] = -2;
		let jlstz_2to1[8] = -1; let jlstz_2to1[9] = -2;
		let kickTableJLSTZ[3] = jlstz_2to1;

		//2->L (2->3): Test offsets
		let jlstz_2to3 = Array.new(10);
		let jlstz_2to3[0] = 0; let jlstz_2to3[1] = 0;
		let jlstz_2to3[2] = 1; let jlstz_2to3[3] = 0;
		let jlstz_2to3[4] = 1; let jlstz_2to3[5] = 1;
		let jlstz_2to3[6] = 0; let jlstz_2to3[7] = -2;
		let jlstz_2to3[8] = 1; let jlstz_2to3[9] = -2;
		let kickTableJLSTZ[4] = jlstz_2to3;

		//L->2 (3->2): Reverse of 2->3
		let jlstz_3to2 = Array.new(10);
		let jlstz_3to2[0] = 0; let jlstz_3to2[1] = 0;
		let jlstz_3to2[2] = -1; let jlstz_3to2[3] = 0;
		let jlstz_3to2[4] = -1; let jlstz_3to2[5] = -1;
		let jlstz_3to2[6] = 0; let jlstz_3to2[7] = 2;
		let jlstz_3to2[8] = -1; let jlstz_3to2[9] = 2;
		let kickTableJLSTZ[5] = jlstz_3to2;

		//L->0 (3->0): Test offsets
		let jlstz_3to0 = Array.new(10);
		let jlstz_3to0[0] = 0; let jlstz_3to0[1] = 0;
		let jlstz_3to0[2] = -1; let jlstz_3to0[3] = 0;
		let jlstz_3to0[4] = -1; let jlstz_3to0[5] = -1;
		let jlstz_3to0[6] = 0; let jlstz_3to0[7] = 2;
		let jlstz_3to0[8] = -1; let jlstz_3to0[9] = 2;
		let kickTableJLSTZ[6] = jlstz_3to0;

		//0->L (0->3): Reverse of 3->0
		let jlstz_0to3 = Array.new(10);
		let jlstz_0to3[0] = 0; let jlstz_0to3[1] = 0;
		let jlstz_0to3[2] = 1; let jlstz_0to3[3] = 0;
		let jlstz_0to3[4] = 1; let jlstz_0to3[5] = 1;
		let jlstz_0to3[6] = 0; let jlstz_0to3[7] = -2;
		let jlstz_0to3[8] = 1; let jlstz_0to3[9] = -2;
		let kickTableJLSTZ[7] = jlstz_0to3;

		let kickTableI = Array.new(8);

		//0->R (0->1): Test offsets
		let i_0to1 = Array.new(10);
		let i_0to1[0] = 0; let i_0to1[1] = 0;
		let i_0to1[2] = -2; let i_0to1[3] = 0;
		let i_0to1[4] = 1; let i_0to1[5] = 0;
		let i_0to1[6] = -2; let i_0to1[7] = -1;
		let i_0to1[8] = 1; let i_0to1[9] = 2;
		let kickTableI[0] = i_0to1;

		//R->0 (1->0): Reverse 0->1
		let i_1to0 = Array.new(10);
		let i_1to0[0] = 0; let i_1to0[1] = 0;
		let i_1to0[2] = 2; let i_1to0[3] = 0;
		let i_1to0[4] = -1; let i_1to0[5] = 0;
		let i_1to0[6] = 2; let i_1to0[7] = 1;
		let i_1to0[8] = -1; let i_1to0[9] = -2;
		let kickTableI[1] = i_1to0;

		//R->2 (1->2): Test offsets
		let i_1to2 = Array.new(10);
		let i_1to2[0] = 0; let i_1to2[1] = 0;
		let i_1to2[2] = -1; let i_1to2[3] = 0;
		let i_1to2[4] = 2; let i_1to2[5] = 0;
		let i_1to2[6] = -1; let i_1to2[7] = 2;
		let i_1to2[8] = 2; let i_1to2[9] = -1;
		let kickTableI[2] = i_1to2;

		//2->R (2->1): Reverse of 1->2
		let i_2to1 = Array.new(10);
		let i_2to1[0] = 0; let i_2to1[1] = 0;
		let i_2to1[2] = 1; let i_2to1[3] = 0;
		let i_2to1[4] = -2; let i_2to1[5] = 0;
		let i_2to1[6] = 1; let i_2to1[7] = -2;
		let i_2to1[8] = -2; let i_2to1[9] = 1;
		let kickTableI[3] = i_2to1;

		//2->L (2->3): Test offsets
		let i_2to3 = Array.new(10);
		let i_2to3[0] = 0; let i_2to3[1] = 0;
		let i_2to3[2] = 2; let i_2to3[3] = 0;
		let i_2to3[4] = -1; let i_2to3[5] = 0;
		let i_2to3[6] = 2; let i_2to3[7] = 1;
		let i_2to3[8] = -1; let i_2to3[9] = -2;
		let kickTableI[4] = i_2to3;

		//L->2 (3->2): Reverse of 2->3
		let i_3to2 = Array.new(10);
		let i_3to2[0] = 0; let i_3to2[1] = 0;
		let i_3to2[2] = -2; let i_3to2[3] = 0;
		let i_3to2[4] = 1; let i_3to2[5] = 0;
		let i_3to2[6] = -2; let i_3to2[7] = -1;
		let i_3to2[8] = 1; let i_3to2[9] = 2;
		let kickTableI[5] = i_3to2;

		//L->0 (3->0): Test offsets
		let i_3to0 = Array.new(10);
		let i_3to0[0] = 0; let i_3to0[1] = 0;
		let i_3to0[2] = 1; let i_3to0[3] = 0;
		let i_3to0[4] = -2; let i_3to0[5] = 0;
		let i_3to0[6] = 1; let i_3to0[7] = -2;
		let i_3to0[8] = -2; let i_3to0[9] = 1;
		let kickTableI[6] = i_3to0;

		//0->L (0->3): Reverse of 3->0
		let i_0to3 = Array.new(10);
		let i_0to3[0] = 0; let i_0to3[1] = 0;
		let i_0to3[2] = -1; let i_0to3[3] = 0;
		let i_0to3[4] = 2; let i_0to3[5] = 0;
		let i_0to3[6] = -1; let i_0to3[7] = 2;
		let i_0to3[8] = 2; let i_0to3[9] = -1;
		let kickTableI[7] = i_0to3;

		return;
	}

	method void disposeKickTables() {
		var int i;
		var Array kickArray;

		if (~(kickTableJLSTZ = null)) {
			let i = 0;
			while (i < 8) {
				let kickArray = kickTableJLSTZ[i];
				do kickArray.dispose();
				let i = i + 1;
			}
			do kickTableJLSTZ.dispose();
		}

		if (~(kickTableI = null)) {
			let i = 0;
			while (i < 8) {
				let kickArray = kickTableI[i];
				do kickArray.dispose();
				let i = i + 1;
			}
			do kickTableI.dispose();
		}
		return;
	}
}
