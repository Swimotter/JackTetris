class TetrisGame {
    field Grid grid;
    field Blocks currentBlock;
    field Bag bag;
    field int score;
    field int level;
    field int linesCleared;
    field boolean gameOver;
    field int dropCounter;
    field int dropSpeed;
    
    constructor TetrisGame new() {
        let grid = Grid.new(10, 20);
        let bag = Bag.new(12345); // seed for random
        let currentBlock = null;
        let score = 0;
        let level = 1;
        let linesCleared = 0;
        let gameOver = false;
        let dropCounter = 0;
        let dropSpeed = 30; // frames between auto-drop
        
        do MemoryTracker.allocGame();
        return this;
    }
    
    method void run() {
        var char key;
        var boolean moved;
        var int i;
        
        do Screen.clearScreen();
        do grid.draw();
        do drawUI();
        do spawnNewBlock();
        
        while (~gameOver) {
            let key = Keyboard.keyPressed();
            let moved = false;
            
            // Handle input
            if (key = 130) { // left arrow
                if (canMove(-1, 0)) {
                    do currentBlock.moveLeft(grid);
                    let moved = true;
                }
            }
            if (key = 132) { // right arrow
                if (canMove(1, 0)) {
                    do currentBlock.moveRight(grid);
                    let moved = true;
                }
            }
            if (key = 133) { // down arrow
                if (canMove(0, 1)) {
                    do currentBlock.moveDown(grid);
                    let moved = true;
                    let score = score + 1; // bonus for soft drop
                    do drawUI();
                }
            }
            if (key = 131) { // up arrow - rotate
                if (canRotate()) {
                    let moved = true;
                }
            }
            if (key = 32) { // space - hard drop
                do hardDrop();
                let moved = true;
            }
            
            // Auto drop
            let dropCounter = dropCounter + 1;
            if (dropCounter > dropSpeed) {
                let dropCounter = 0;
                if (canMove(0, 1)) {
                    do currentBlock.moveDown(grid);
                } else {
                    do lockBlock();
                }
            }
            
            // Small delay for responsiveness
            do Sys.wait(5);
        }
        
        // Game over screen
        do showGameOver();
        
        return;
    }
    
    method boolean canMove(int dx, int dy) {
        var Array shape;
        var int i, cellX, cellY;
        var int newX, newY;
        
        let shape = currentBlock.getShape();
        let newX = currentBlock.getX() + dx;
        let newY = currentBlock.getY() + dy;
        let i = 0;
        
        // Check each cell of the block at the new position
        while (i < 8) {
            let cellX = newX + shape[i];
            let cellY = newY + shape[i + 1];
            
            // Check if out of bounds
            if (~grid.inBounds(cellX, cellY)) {
                return false;
            }
            
            // Check if cell is occupied
            if (~grid.isEmpty(cellX, cellY)) {
                return false;
            }
            
            let i = i + 2;
        }
        
        return true;
    }
    
    method boolean canRotate() {
        var int oldRotation;
        var Array shape;
        var int i, cellX, cellY;
        var boolean valid;
        
        let oldRotation = currentBlock.getRotation();
        
        // Temporarily rotate to test
        do currentBlock.rotate(grid);
        
        // Check if valid at current position
        let valid = currentBlock.isValidPosition(grid);
        
        // If invalid, rotate back
        if (~valid) {
            do currentBlock.unrotate(grid);
        }
        
        return valid;
    }
    
    method void hardDrop() {
        var int dropDistance;
        let dropDistance = 0;
        
        while (canMove(0, 1)) {
            do currentBlock.moveDown(grid);
            let dropDistance = dropDistance + 1;
        }
        
        let score = score + (dropDistance * 2); // bonus for hard drop
        do lockBlock();
        
        return;
    }
    
    method void lockBlock() {
        var int cleared;
        
        do grid.placeBlock(currentBlock);
        do currentBlock.dispose();
        let currentBlock = null;
        
        // Check for line clears
        let cleared = grid.clearLines();
        
        if (cleared > 0) {
            let linesCleared = linesCleared + cleared;
            
            // Update score based on lines cleared
            if (cleared = 1) { let score = score + (100 * level); }
            if (cleared = 2) { let score = score + (300 * level); }
            if (cleared = 3) { let score = score + (500 * level); }
            if (cleared = 4) { let score = score + (800 * level); }
            
            // Update level every 10 lines
            let level = (linesCleared / 10) + 1;
            
            // Increase speed with level (cap at 5 frames)
            let dropSpeed = 35 - (level * 2);
            if (dropSpeed < 5) {
                let dropSpeed = 5;
            }
            
            do grid.draw();
            do drawUI();
        }
        
        // Spawn next block
        do spawnNewBlock();
        
        return;
    }
    
    method void spawnNewBlock() {
        var int blockType;
        
        let blockType = bag.getNextBlock();
        let currentBlock = Blocks.new(blockType);
        
        // Check if spawn position is valid (game over check)
        if (~currentBlock.isValidPosition(grid)) {
            let gameOver = true;
            return;
        }
        
        do currentBlock.draw(grid);
        
        return;
    }
    
    method void drawUI() {
        var int textX, textY;
        
        let textX = 1;
        let textY = 1;
        
        // Draw score (moved to avoid grid area)
        do Output.moveCursor(1, 35);
        do Output.printString("Score: ");
        do Output.printInt(score);
        do Output.printString("      ");
        
        // Draw level
        do Output.moveCursor(2, 35);
        do Output.printString("Level: ");
        do Output.printInt(level);
        do Output.printString("      ");
        
        // Draw lines
        do Output.moveCursor(3, 35);
        do Output.printString("Lines: ");
        do Output.printInt(linesCleared);
        do Output.printString("      ");
        
        // Draw controls
        do Output.moveCursor(5, 35);
        do Output.printString("Arrows: Move");
        do Output.moveCursor(6, 35);
        do Output.printString("Up: Rotate");
        do Output.moveCursor(7, 35);
        do Output.printString("Space: Drop");
        
        return;
    }
    
    method void showGameOver() {
        do Output.moveCursor(11, 22);
        do Output.printString("GAME OVER!");
        do Output.moveCursor(12, 19);
        do Output.printString("Final Score: ");
        do Output.printInt(score);
        
        return;
    }
    
    method void dispose() {
        if (~(currentBlock = null)) {
            do currentBlock.dispose();
        }
        do grid.dispose();
        do bag.dispose();
        do Memory.deAlloc(this);
        do MemoryTracker.freeGame();
        return;
    }
}