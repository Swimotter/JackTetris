class Bag {
    field Array currentBag;
    field Array nextBag;
    field int bagIndex;
    field int seed;
    field boolean hasNextBag;

    constructor Bag new (int initSeed) {
        let seed = initSeed;
        let bagIndex = 7; //Force initial bag fill
        let hasNextBag = false;

        do MemoryTracker.allocBag();

        let currentBag = Array.new(7);
        do MemoryTracker.allocArray();

        let nextBag = Array.new(7);
        do MemoryTracker.allocArray();

        return this;
    }

    //Fills and shuffles a new bag of blocks
    method void fillBagArray(Array bag) {
        var int i,j,temp;

        //Fill bag with one of each block type
        let bag[0] = 0; //I
        let bag[1] = 1; //J
        let bag[2] = 2; //L
        let bag[3] = 3; //O
        let bag[4] = 4; //S
        let bag[5] = 5; //T
        let bag[6] = 6; //Z

        /* Shuffle bag using Fisher-Yates algorithm
        *  Write down numbers from 1 to N
        *  Pick random number k between 1 and the number of unstruck numbers
        *  Counting from the low end, strike out the kth unstruck number and write it down as next number
        *  Repeat until all numbers are struck out
        */
        let i = 6;
        while (i > 0) {
            let j = Math.abs(seed) - ((Math.abs(seed) / (i + 1)) * (i + 1)); //j = random int between 0 and i a % b = a - (a / b) * b

            //swap i and J
            let temp = bag[i];
            let bag[i] = bag[j];
            let bag[j] = temp;

            //update seed for next random number
            //using 16-bit friendly LCG: seed = (seed * 25173 + 13849) mod 2^16
            //25173 and 13849 are constants that work well for 16-bit LCG
            let seed = (seed * 25173) + 13849;
            //let seed = (seed * 1103515245) + 12345; //1103515245 and 12345 are magic numbers from rand func in C
            let i = i - 1;
        }
        return;
    }

    //Get next block from the bag
    method int getNextBlock() {
        var int blockType;

        if (bagIndex > 6) {
            if (hasNextBag) {
                //Swap bags
                do currentBag.dispose(); //dispose of current bag array
                do MemoryTracker.freeArray();
                
                let currentBag = nextBag;
                let nextBag = Array.new(7);
                do MemoryTracker.allocArray();
                let bagIndex = 0;

                //Refill next bag
                do fillBagArray(nextBag);
            } else {
                //First time filling bag
                do fillBagArray(currentBag);
                let bagIndex = 0;

                //prepare next bag
                do fillBagArray(nextBag);
                let hasNextBag = true;
            }
        }

        let blockType = currentBag[bagIndex];
        let bagIndex = bagIndex + 1;
        return blockType;
    }

    //Peek at Nth pieces without consuming
    method int peek(int offset) {
        var int realIndex;

        if (offset < 0) {return -1;} //invalid offset

        let realIndex = bagIndex + offset;

        //within current bag
        if (realIndex < 7) {
            return currentBag[realIndex];
        }

        //within next bag (7-13)
        if (realIndex < 14) {
            if (~hasNextBag) {
                do fillBagArray(nextBag);
                let hasNextBag = true;
            }
            return nextBag[realIndex - 7];
        }
        //beyond next bag
        return -1;
    }

    method void dispose() {
        do currentBag.dispose(); //dispose of array
        do MemoryTracker.freeArray();

        do nextBag.dispose(); //dispose of array
        do MemoryTracker.freeArray();

        do Memory.deAlloc(this); //dispose of bag object
        do MemoryTracker.freeBag();
        return;
    }
}