class Grid {
    field Array board; //2D array representing grid
    field int width, height;
    field boolean borderDrawn; //to avoid redrawing border unnecessarily
    static int cellSize;
    static int offsetX, offsetY;

    /**
     0                196px              316px            512px
     ├──────────────────┼──────────────────┼──────────────┤
   0 ┤                  │                  │              │
     │                  │                  │              │
   8 ┤                  ┌──────────────────┐              │
     │                  │                  │              │
     │     LEFT         │   TETRIS BOARD   │    RIGHT     │
     │    SPACE         │   (120×240 px)   │    SPACE     │
     │   (196 px)       │                  │   (196 px)   │
     │                  │                  │              │
 248 ┤                  └──────────────────┘              │
     │                  │                  │              │
 256 ┴──────────────────┴──────────────────┴──────────────┘
     0                196px              316px            512px

    Cell size = 12x12 pixels
    Grid size = 10x20 cells

    **/
    function void init() {
        let  cellSize = 12;
        let  offsetX = 195; // (512 - (10*12)) / 2 = 196 (moved left 1 pixel for aesthetics)
        let  offsetY = 7; // (256 - (20*12)) / 2 = 8 (moved up 1 pixel for aesthetics)
        return;
    }

    constructor Grid new (int w, int h) {
        let width = w;
        let height = h;
        let board = Array.new(width * height);
        let borderDrawn = false;

        do MemoryTracker.allocGrid();
        do MemoryTracker.allocArray();
        do clear();
        return this;
    }

    //convert 2D coords to 1D index
    method int getIndex(int x, int y) {
        return (y * width) + x;
    }

    //bounds check
    method boolean inBounds(int x, int y) {
        return (~(x < 0 | x > (width - 1) | y < 0 | y > (height - 1))); //all parenthesis necessary
    }

    //occupancy check
    method boolean isEmpty(int x, int y) {
        var int index;
        if (~inBounds(x, y)) {return false;}
        let index = getIndex(x, y);
        return board[index] = 0;
    }

    //valid position check for block
    method boolean isValidCell(int x, int y) {
        if (~inBounds(x, y)) {return false;}
        return isEmpty(x, y);
    }

    //check if block can be placed at its current position
    method boolean canPlaceBlock(Blocks block) {
        var Array shape;
        var int i, cellX, cellY;

        let shape = block.getShape();
        let i = 0;

        while (i < 8) { //4 pairs of (dx, dy)
            let cellX = block.getX() + shape[i];
            let cellY = block.getY() + shape[i + 1];
            if (~isValidCell(cellX, cellY)) {
                return false;
            }
            let i = i + 2; //next pair
        }
        return true;
    }

    //Place block on grid (make cells occupied)
    method void placeBlock(Blocks block) {
        var Array shape;
        var int i, cellX, cellY, index;
        var int blockType;

        let shape = block.getShape();
        let blockType = block.getType() + 1; //Store as 1-7 to differentiate from empty(0)
        let i = 0;
        while (i < 8) { //4 pairs of (dx, dy)
            let cellX = block.getX() + shape[i];
            let cellY = block.getY() + shape[i + 1];

            if (inBounds(cellX, cellY)) {
                let index = getIndex(cellX, cellY);
                let board[index] = blockType;

                do drawCell(cellX, cellY);
            }
            let i = i + 2; //next pair
        }
        return;
    }

    method boolean isLineFull(int row) {
        var int col;
        let col = 0;

        while (col < width) {
            if (isEmpty(col, row)) {
                return false;
            }
            let col = col + 1;
        }
        return true;
    }

    method void clearLine(int row) {
        var int currentRow, col, index, aboveIndex;

        if (~inBounds(0, row)) {return;}

        //start from cleared row and move up
        let currentRow = row;
        while (currentRow > 0) {
            let col = 0;
            while (col < width) {
                let index = getIndex(col, currentRow);
                let aboveIndex = getIndex(col, currentRow - 1);
                let board[index] = board[aboveIndex];
                let col = col + 1;
            }
            let currentRow = currentRow - 1;
        }
        //Clear top row
        let col = 0;
        while (col < width) {
            let index = getIndex(col, 0);
            let board[index] = 0;
            let col = col + 1;
        }
            return;
    }

    method int clearLines() {
        var int row, linesCleared, topAffectedRow;
        let row = height - 1;
        let linesCleared = 0;
        let topAffectedRow = height;

        while (row > -1) {
            if (isLineFull(row)) {
                do clearLine(row);
                let linesCleared = linesCleared + 1;
                let topAffectedRow = row;
            } else {
                let row = row - 1;
            }
        }

        if (linesCleared > 0) {
            do drawRows(0, topAffectedRow + linesCleared - 1);
        }
        return linesCleared;
    }

    method int getCell(int x, int y) {
        var int index;
        if (~inBounds(x, y)) {return -1;}
        let index = getIndex(x, y);
        return board[index];
    }

    method void drawBorder() {
        do Screen.setColor(true);
        do Screen.drawRectangle(
            offsetX - 2,
            offsetY - 2,
            offsetX + (cellSize * width) + 1,
            offsetY + (cellSize * height) + 1
        );
        do Screen.setColor(false);
        do Screen.drawRectangle(
            offsetX - 1,
            offsetY - 1,
            offsetX + (cellSize * width),
            offsetY + (cellSize * height)
        );
        let borderDrawn = true;
        return;
    }

    method void draw() { //full redraw

        if (~borderDrawn) {
            do drawBorder();
        }
        do drawRows(0, height - 1);
        return;
    }

    method void drawCellAt(int col, int row, boolean filled) {
        var int x1, y1, x2, y2;

        if (~inBounds(col, row)) {return;}

        let x1 = offsetX + (col * cellSize);
        let y1 = offsetY + (row * cellSize);
        let x2 = x1 + cellSize - 1;
        let y2 = y1 + cellSize - 1;

        do Screen.setColor(filled);
        do Screen.drawRectangle(x1, y1, x2, y2);
        return;
    }

    method void drawCell(int col, int row) {
        var int cellValue, index;

        if (~inBounds(col, row)) {return;}
        let index = getIndex(col, row);
        let cellValue = board[index];
        do drawCellAt(col, row, cellValue > 0); //filled if > 0
        return;
    }

    method void drawRows(int startRow, int endRow) { //draw only specific rows (optimized for line clears)
        var int row, col;

        let row = startRow;
        while (row < endRow + 1) {
            if (inBounds(0, row)) {
                let col = 0;
                while (col < width) {
                    do drawCell(col, row);
                    let col = col + 1;
                }
            }
            let row = row + 1;
        }
        return;
    }

    method void clear() {
        var int i;
        let i = 0;

        while (i < (width * height)) {
            let board[i] = 0; //0 represents empty cell
            let i = i + 1;
        }
        let borderDrawn = false;
        return;
    }

    //Getters
    method int getWidth() {return width;}
    method int getHeight() {return height;}
    function int getCellSize() {return cellSize;}
    function int getOffsetX() {return offsetX;}
    function int getOffsetY() {return offsetY;}

    method void dispose() {
        do board.dispose();
        do MemoryTracker.freeArray();
        do Memory.deAlloc(this);
        do MemoryTracker.freeGrid();
        return;
    }
}