class Blocks {
	//Block types
	static int I, J, L, O, S, T, Z;

	//Block states
	field int type;
	field int rotation; //0-3
	field int x,y; //Pos on grid
	field Array shape; //store shape array as field to avoid reallocation
	field Array shape; //store shape array as field to avoid reallocation

	constructor Blocks new (int blockType) {
		let type = blockType;
		let rotation = 0;
		let x = 3;//start at top-center
		let y = 0;
		do MemoryTracker.allocBlock();
		let shape = Array.new(8); //4 pairs of (dx, dy) offset from origin
		do MemoryTracker.allocArray();
		do updateShape(); //fill with intial shape
		do MemoryTracker.allocBlock();
		let shape = Array.new(8); //4 pairs of (dx, dy) offset from origin
		do MemoryTracker.allocArray();
		do updateShape(); //fill with intial shape
		return this;
	}

	function void init() {
		let I = 0;
		let J = 1;
		let L = 2;
		let O = 3;
		let S = 4;
		let T = 5;
		let Z = 6;
		return;
	}
	
	method void updateShape() {
		/*
		4x4 grid representation for reference:
		[][][][]
		[][][][]
		[][][][]
		[][][][]
		
		3x3 grid locked to top-left
		[][][]
		[][][]
		[][][]
		*/

		if (type = 0) { //I
			if (rotation = 0) {
				//[][][][]
				let shape[0] = 0; let shape[1] = 1;
				let shape[2] = 1; let shape[3] = 1;
				let shape[4] = 2; let shape[5] = 1;
				let shape[6] = 3; let shape[7] = 1;
			} if (rotation = 1) {
				//[]
				//[]
				//[]
				//[]
				let shape[0] = 2; let shape[1] = 0;
				let shape[2] = 2; let shape[3] = 1;
				let shape[4] = 2; let shape[5] = 2;
				let shape[6] = 2; let shape[7] = 3;
			} if (rotation = 2) {
				//
				//[][][][]
				let shape[0] = 0; let shape[1] = 2;
				let shape[2] = 1; let shape[3] = 2;
				let shape[4] = 2; let shape[5] = 2;
				let shape[6] = 3; let shape[7] = 2;
			} if (rotation = 3) {
				//    []
				//    []
				//    []
				//    []
				let shape[0] = 1; let shape[1] = 0;
				let shape[2] = 1; let shape[3] = 1;
				let shape[4] = 1; let shape[5] = 2;
				let shape[6] = 1; let shape[7] = 3;
			}
		}
		if (type = 1) { //J
			if (rotation = 0) {
				//	[]
				//	[]
				//[][]
				let shape[0] = 1; let shape[1] = 0;
				let shape[2] = 1; let shape[3] = 1;
				let shape[4] = 0; let shape[5] = 2;
				let shape[6] = 1; let shape[7] = 2;
			} if (rotation = 1) {
				//[]
				//[][][]
				let shape[0] = 0; let shape[1] = 0;
				let shape[2] = 0; let shape[3] = 1;
				let shape[4] = 1; let shape[5] = 1;
				let shape[6] = 2; let shape[7] = 1;
			} if (rotation = 2) {
				//  [][]
				//  []
				//  []
				let shape[0] = 1; let shape[1] = 0;
				let shape[2] = 2; let shape[3] = 0;
				let shape[4] = 1; let shape[5] = 1;
				let shape[6] = 1; let shape[7] = 2;
			} if (rotation = 3) {
				//
				//[][][]
				//	  []
				let shape[0] = 0; let shape[1] = 1;
				let shape[2] = 1; let shape[3] = 1;
				let shape[4] = 2; let shape[5] = 1;
				let shape[6] = 2; let shape[7] = 2;
			}
		}
		if (type = 2) { //L
			//Similar to J but mirrored
			if (rotation = 0) {
				//  []
				//  []
				//  [][]
				let shape[0] = 1; let shape[1] = 0;
				let shape[2] = 1; let shape[3] = 1;
				let shape[4] = 1; let shape[5] = 2;
				let shape[6] = 2; let shape[7] = 2;
			} if (rotation = 1) {
				//[][][]
				//[]
				let shape[0] = 0; let shape[1] = 1;
				let shape[2] = 1; let shape[3] = 1;
				let shape[4] = 2; let shape[5] = 1;
				let shape[6] = 0; let shape[7] = 2;
			} if (rotation = 2) {
				//[][]
				//  []
				//  []
				let shape[0] = 0; let shape[1] = 0;
				let shape[2] = 1; let shape[3] = 0;
				let shape[4] = 1; let shape[5] = 1;
				let shape[6] = 1; let shape[7] = 2;
			} if (rotation = 3) {
				//    []
				//[][][]
				let shape[0] = 2; let shape[1] = 0;
				let shape[2] = 0; let shape[3] = 1;
				let shape[4] = 1; let shape[5] = 1;
				let shape[6] = 2; let shape[7] = 1;
			}
		}
		if (type = 3) { //O
			//  [][]
			//  [][]
			let shape[0] = 1; let shape[1] = 0;
			let shape[2] = 2; let shape[3] = 0;
			let shape[4] = 1; let shape[5] = 1;
			let shape[6] = 2; let shape[7] = 1;
		}
		if (type = 4) { //S
			if (rotation = 0) {
				//	[][]  
				//[][]
				let shape[0] = 1; let shape[1] = 0;
				let shape[2] = 2; let shape[3] = 0;
				let shape[4] = 0; let shape[5] = 1;
				let shape[6] = 1; let shape[7] = 1;
			} if (rotation = 1) {
				//[]
				//[][]
				//  []
				let shape[0] = 1; let shape[1] = 0;
				let shape[2] = 1; let shape[3] = 1;
				let shape[4] = 2; let shape[5] = 1;
				let shape[6] = 2; let shape[7] = 2;
			} if (rotation = 2) {
				//	[][]  
				//[][]
				let shape[0] = 1; let shape[1] = 1;
				let shape[2] = 2; let shape[3] = 1;
				let shape[4] = 0; let shape[5] = 2;
				let shape[6] = 1; let shape[7] = 2;
			} if (rotation = 3) {
				//[]
				//[][]
				//  []
				let shape[0] = 0; let shape[1] = 0;
				let shape[2] = 0; let shape[3] = 1;
				let shape[4] = 1; let shape[5] = 1;
				let shape[6] = 1; let shape[7] = 2;
			}
		}
		if (type = 5) { //T
			if (rotation = 0) {
				//  []
				//[][][]
				let shape[0] = 1; let shape[1] = 0;
				let shape[2] = 0; let shape[3] = 1;
				let shape[4] = 1; let shape[5] = 1;
				let shape[6] = 2; let shape[7] = 1;
			} if (rotation = 1) {
				//[]
				//[][]
				//[]
				let shape[0] = 1; let shape[1] = 0;
				let shape[2] = 1; let shape[3] = 1;
				let shape[4] = 2; let shape[5] = 1;
				let shape[6] = 1; let shape[7] = 2;
			} if (rotation = 2) {
				//[][][]
				//  []
				let shape[0] = 0; let shape[1] = 1;
				let shape[2] = 1; let shape[3] = 1;
				let shape[4] = 2; let shape[5] = 1;
				let shape[6] = 1; let shape[7] = 2;
				
			} if (rotation = 3) {
				//  []
				//[][]
				//  []
				let shape[0] = 1; let shape[1] = 0;
				let shape[2] = 0; let shape[3] = 1;
				let shape[4] = 1; let shape[5] = 1;
				let shape[6] = 1; let shape[7] = 2;
			}
		}
		if (type = 6) { //Z
			if (rotation = 0) {
				//[][]  
				//  [][]
				let shape[0] = 0; let shape[1] = 0;
				let shape[2] = 1; let shape[3] = 0;
				let shape[4] = 1; let shape[5] = 1;
				let shape[6] = 2; let shape[7] = 1;
			} if (rotation = 1) {
				//    []
				//  [][]
				//  []
				let shape[0] = 2; let shape[1] = 0;
				let shape[2] = 1; let shape[3] = 1;
				let shape[4] = 2; let shape[5] = 1;
				let shape[6] = 1; let shape[7] = 2;
			} if (rotation = 2) {
				//
				//[][]  
				//  [][]
				let shape[0] = 0; let shape[1] = 1;
				let shape[2] = 1; let shape[3] = 1;
				let shape[4] = 1; let shape[5] = 2;
				let shape[6] = 2; let shape[7] = 2;
			} if (rotation = 3) {
				//  []
				//[][]
				//[]
				let shape[0] = 1; let shape[1] = 0;
				let shape[2] = 0; let shape[3] = 1;
				let shape[4] = 1; let shape[5] = 1;
				let shape[6] = 0; let shape[7] = 2;
			}
		}
		return;
	}

	//Checks
	//Checks
	method boolean isValidPosition(Grid grid) {
		return grid.canPlaceBlock(this);
	}

	//Getters
	method int getType() {return type;}
	method int getRotation() {return rotation;}
	method int getX() {return x;}
	method int getY() {return y;}
	method Array getShape() {return shape;}

	// Erase current 4 cells - draw directly to screen
	method void erase(Grid grid) {
		var int i, cellX, cellY;
		var int x1, y1, x2, y2;
		var int cellSize, offsetX, offsetY;
		
		let cellSize = grid.getCellSize();
		let offsetX = grid.getOffsetX();
		let offsetY = grid.getOffsetY();
		
		let i = 0;
		while (i < 8) { //4 pairs of (dx, dy)
			let cellX = x + shape[i];
			let cellY = y + shape[i + 1];
			
			// Only erase if within bounds and cell is empty in grid
			if (grid.inBounds(cellX, cellY)) {
				if (grid.isEmpty(cellX, cellY)) {
					let x1 = offsetX + (cellX * cellSize);
					let y1 = offsetY + (cellY * cellSize);
					let x2 = x1 + cellSize - 1;
					let y2 = y1 + cellSize - 1;
					
					do Screen.setColor(false);
					do Screen.drawRectangle(x1, y1, x2, y2);
				}
			}
			
			let i = i + 2;
		}
		return;
	}

	//Movement (now erase old cells and redraw the new ones)
	method void moveLeft(Grid grid) { 
		do erase(grid);
		let x = x - 1; 
		do draw(grid);
		return; 
	}
	method void moveRight(Grid grid) { 
		do erase(grid);
		let x = x + 1; 
		do draw(grid);
		return; 
	}
	method void moveDown(Grid grid) { 
		do erase(grid);
		let y = y + 1; 
		do draw(grid);
		return; 
	}
	method void moveUp(Grid grid) { 
		do erase(grid);
		let y = y - 1; 
		do draw(grid);
		return; 
	}
	method void rotate(Grid grid) { 
		// erase current cells, change rotation, update shape, draw new cells
		do erase(grid);
		let rotation = (rotation + 1);  
		if (rotation > 3){let rotation = 0;}
		do updateShape();
		do draw(grid);
		return; 
	}
	method void unrotate(Grid grid) {
		do erase(grid);
		let rotation = (rotation - 1);  
		if (rotation < 0){let rotation = 3;}
		do updateShape();
		do draw(grid);
		return; 
	}
	method void setPosition(int newX, int newY, Grid grid) {
		do erase(grid);
		let x = newX;
		let y = newY;
		do draw(grid);
		return;
	}

	method void draw(Grid grid) {
		var int i, cellX, cellY;
		var int x1, y1, x2, y2;
		var int cellSize, offsetX, offsetY;
		
		let cellSize = grid.getCellSize();
		let offsetX = grid.getOffsetX();
		let offsetY = grid.getOffsetY();
		
		do Screen.setColor(true);
		let i = 0;
		while (i < 8) { //4 pairs of (dx, dy)
			let cellX = x + shape[i];
			let cellY = y + shape[i + 1];
			
			// Draw directly to screen
			if (grid.inBounds(cellX, cellY)) {
				let x1 = offsetX + (cellX * cellSize);
				let y1 = offsetY + (cellY * cellSize);
				let x2 = x1 + cellSize - 1;
				let y2 = y1 + cellSize - 1;
				
				do Screen.drawRectangle(x1, y1, x2, y2);
			}
			
			let i = i + 2; //next pair
		}
		return;
	}

	method void dispose() {
		do shape.dispose(); //dispose shape array
		do MemoryTracker.freeArray();
		do Memory.deAlloc(this);
		do MemoryTracker.freeBlock();
		return;
	}
}
